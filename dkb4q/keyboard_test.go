package dkb4q

import (
	"context"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/octo/das/dkb4q/fake"
)

func TestGetReports(t *testing.T) {
	cases := []struct {
		title     string
		responses [][]byte
		want      [][]byte
		wantErr   bool
	}{
		{
			title:     "base",
			responses: [][]byte{{0xED, 0x03, 0x78, 0x00, 0x96, 0x00, 0x00, 0x00}},
			want:      [][]byte{{0xED, 0x03, 0x78, 0x00, 0x96}},
		},
		{
			title: "batch",
			responses: [][]byte{
				{0xED, 0x03, 0x78, 0x00, 0x96, 0xED, 0x03, 0x78},
				{0x00, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			want: [][]byte{
				{0xED, 0x03, 0x78, 0x00, 0x96},
				{0xED, 0x03, 0x78, 0x00, 0x96},
			},
		},
		{
			title: "initial zero response",
			responses: [][]byte{
				{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				{0xED, 0x03, 0x78, 0x00, 0x96, 0x00, 0x00, 0x00},
			},
			want: [][]byte{{0xED, 0x03, 0x78, 0x00, 0x96}},
		},
		{
			title: "intermittent zero response",
			responses: [][]byte{
				{0xED, 0x03, 0x78, 0x00, 0x96, 0xED, 0x03, 0x78},
				{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				{0x00, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			want: [][]byte{
				{0xED, 0x03, 0x78, 0x00, 0x96},
				{0xED, 0x03, 0x78, 0x00, 0x96},
			},
		},
		{
			title:     "checksum mismatch",
			responses: [][]byte{{0xED, 0x03, 0x78, 0x00, 0xEE, 0x00, 0x00, 0x00}},
			wantErr:   true,
		},
		{
			title:     "invalid length",
			responses: [][]byte{{0xED, 0x00, 0x78, 0x00, 0x95, 0x00, 0x00, 0x00}},
			wantErr:   true,
		},
		{
			title: "issue#2",
			responses: [][]byte{{0xed, 0x3, 0x78, 0x0, 0x96, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x9a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}},
			want: [][]byte{
				{0xED, 0x03, 0x78, 0x00, 0x96},
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.title, func(t *testing.T) {
			var (
				ctx = context.Background()
				hid fake.HID
			)

			for _, res := range tc.responses {
				hid.WantGetReport = append(hid.WantGetReport, fake.Report{
					ID:   1,
					Data: res,
				})
			}
			kb := &Keyboard{
				dev: &hid,
			}
			defer kb.Close()

			got, err := kb.getReports(ctx)
			if gotErr := err != nil; gotErr != tc.wantErr {
				t.Errorf("getReports() = %v, want error %v", err, tc.wantErr)
			}
			if tc.wantErr {
				return
			}

			if diff := cmp.Diff(tc.want, got); diff != "" {
				t.Errorf("getReports() differs (+got/-want):\n%s", diff)
			}
		})
	}
}
